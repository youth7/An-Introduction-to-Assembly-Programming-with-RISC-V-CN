# 8.1 内存布局

**存储程序**（stored-program）计算机体系结构是一种在内存中同时存储数据和代码的计算机体系结构。**冯·依曼架构**是一种计算机体系结构，它将数据和代码存储在同一个地址空间中。大多数现代计算机结构都是冯·诺依曼架构。

图8.1展示了在冯·诺依曼架构的内存上组织程序的一种常见方式。

* **代码空间是存储程序代码的内存空间**，通常放低地址的开头。
* **静态数据空间是存储程序静态数据**（例如全局变量）的内存空间，放置在代码空间之后。
* **堆空间是由内存分配库管理的内存空间**，分配在静态数据空间之后。堆一开始很小，每当内存分配库需要更多空间时，它都会调用操作系统增大堆区域，这是通过增加 *程序中断*（program break，它定义了堆空间的结尾）地址来实现的。
* 最后，**栈空间是存储程序栈的内存空间**，通常放置在内存的末尾（即高地址）。

![](./imgs/ch8/8.1.png)

> 图8.1 



# 8.2 程序的栈

活跃例程（An active routine）是被调用但尚未返回的例程。请注意，在给定的执行点上可能有多个活动例程。

```c
int a = 10;

int main()
{
    return bar() + 2;
}
int bar()
{
    return fun() + 4;
}
int fun()
{
    return a;
}
```

例如下面的代码中，例程`fun`被例程`bar`调用，而`bar`被例程`main`调用。一开始`main`是活跃的，然后它调用`bar`，该例程也变为活跃状态。最后调用`fun`，它也变为活跃状态。此时系统中有3个活跃例程。

每当调用例程时，活跃例程的集合增加；每当例程返回时，活跃例程的集合减少。例程以后进先出的方式激活和停用，即最后一个被激活的例程必须是第一个被停用的例程。因此，**用于跟踪活跃例程的最自然的数据结构是栈**。

例程通常需要内存空间来存储重要信息，如局部变量、参数和返回地址。因此，每当调用一个例程（并进入活跃状态）时，系统需要分配内存空间来存储与该例程有关的信息。在它返回（停用）之后，与该例程调用相关的所有信息都不再需要了，内存空间必须被释放。

**程序栈是一个栈数据结构，存储了活跃例程的信息**，如局部变量、参数和返回地址。程序栈存储在主存中，每当调用例程时，有关例程的信息都会压入栈顶，这导致栈增长。而当例程返回时，将栈顶的内容删除后，有关例程的信息将被抛弃，这使得栈收缩。

程序栈是在**栈空间**中分配的，栈空间通常位于内存的末尾（即高位地址的地方）。因此，程序栈必须向低地址增长。

栈指针是一个指向栈顶的指针，它存储了栈顶的地址。通过调整栈指针可以使得程序栈增长或者收缩。

在RISC-V中，**栈指针由寄存器`sp`存储**。此外，在RISC-V中，栈向低地址增长，因此可以通过减小寄存器`sp`（栈指针）的值来增加（或分配）栈上的空间。下面的代码展示了如何将寄存器`a0`的内容压入栈中。首先，减小栈指针以分配空间（4字节），然后使用`sw`指令将寄存器`a0`（4字节）的内容存储在程序栈的顶部

```assembly
addi sp, sp, -4 # 分配栈空间
sw a0, 0(sp) 	# 将数据存储到栈
lw a0, 0(sp) 	# 从栈获取数据
addi sp, sp, 4 	# 回收栈空间
```

图8.2 (a)展示了一个程序栈，它从地址0x0500开始，一直延伸到地址0x04E4。因为栈指针指向栈顶，所以寄存器`sp`的内容等于0x04E4。

图8.2 (b)显示了程序栈在执行以下代码（即将寄存器a0的内容压入栈）之后是如何被修改的。注意栈指针`sp`的值减了4，而寄存器`a0` （0xFA0312B0）的值在内存地址为0x04E0的地方开始存储。

![](./imgs/ch8/8.2.png)

```assembly
li a0, 0xFA0312B0
addi sp, sp, -4 # 分配栈空间
sw a0, 0(sp) 	# 往栈中存储数据
```

前面的例子讨论了如何在栈中插入和弹出一个4字节的字（word）。在许多情况下，程序可能需要向栈中插入或弹出多个值。例如程序可能需要在栈上保存一组寄存器值。此时可以对代码进行优化，只调整（增加或减少）一次栈指针的值。下面展示了如何将4个值从寄存器`a0`、`a1`、`a2`和`a3`压入程序栈。注意栈指针只调整了一次，`sw`指令的参数中的立即数用于指定值在栈中的位置。在这个例子中，最后压入栈的是存储在寄存器`a3`中的值。

```assembly
addi sp, sp, -16 # 分配栈空间 (4个word)
sw a0, 12(sp) 	# 栈上存储第1个值 (SP+12)
sw a1, 8(sp) 	# 栈上存储第2个值 (SP+8)
sw a2, 4(sp) 	# 栈上存储第3个值 (SP+4)
sw a3, 0(sp) 	# 栈上存储第4个值 (SP+0)
```

下面的代码展示了如何将程序栈中的4个值弹出（pop）到寄存器`a3`、`a2`、`a1`和`a0`。注意栈指针只调整了一次，`lw`指令参数中的立即数用于指定被弹出的值的地址。在这个例子中，从栈弹出的第一个值存储在寄存器`a3`中。

```assembly
lw a3, 0(sp) 	# 从栈中获取第1个值 (SP+0)
lw a2, 4(sp) 	# 从栈中获取第2个值 (SP+4)
lw a1, 8(sp) 	# 从栈中获取第3个值 (SP+8)
lw a0, 12(sp) 	# 从栈中获取第4个值 (SP+12)
addi sp, sp, 16 # 回收栈空间
```

前面的例子展示了入栈和出栈的操作。出栈操作包含两步：弹出数据然后释放栈空间，但如果不再需要该数据，则只需要执行释放操作。正如我们将在8.6节和8.4节中讨论的那样，在很多情况下，分配或释放栈空间但不立即对栈空间进行读写操作是很有用的。



**初始化栈指针**

在执行程序之前，栈指针寄存器必须初始化为指向栈底。在没有操作系统支持的情况下（例如嵌入式系统中）运行程序时，**栈指针必须由系统初始化代码初始化。当程序在操作系统上运行时，执行环境（例如操作系统内核）通常会在跳转到程序入口点之前初始化栈指针**。



## 8.2.1 栈的类型

程序栈可以分为以下几种类型：满降序（full descending ）、满升序、空降序和空升序。

**满降序栈是这样一种栈：**

* 栈顶向低地址增长，
* 栈指针指向压入栈的最后一个元素。

将值压入一个满降序栈是通过减小栈指针值，然后将值存储到栈指针指向的内存字中（即栈顶）来实现的。而从一个满降序栈弹出一个值，首先要从栈顶加载值，然后增加栈指针的值。

**空降序栈是这样一种栈：**

* 栈顶向低地址增长，
* 栈指针指向下一个可用的内存位置（即栈顶指针必须指向这样一个位置，该位置用于存储下一个入栈的数据）。

将一个值压入一个空降序栈是这样进行的：首先将该值存储到栈指针指向的内存字（一个空闲的内存单元）中，然后递减栈指针。从一个空降序栈弹出一个值，首先是增加栈指针，然后从栈指针指向的内存字（即栈顶）加载该值。

**满升序栈是这样一种栈：**

* 栈顶指针向高地址增长
* 栈指针指向压入栈的最后一个元素。

将一个值压入一个满升序栈是通过增加栈指针，然后将值存储到栈指针指向的内存字中（即栈顶）来实现的。从一个满升序栈弹出一个值，首先要从栈顶加载值，然后减少栈指针的值。

**空升序栈是这样一种栈：**

* 栈顶向高地址增长，
* 栈指针指向下一个可用的内存位置（即栈顶指针必须指向这样一个位置，该位置用于存储下一个入栈的数据）。

将一个值压入一个空升序栈是这样进行的：首先将该值存储到栈指针指向的内存字（一个空闲的内存单元）中，然后增加栈指针。从一个空降序栈弹出一个值，首先是减少栈指针，然后从栈指针指向的内存字（即栈顶）加载该值。



> 注：RISC-V的程序栈是满降序的



# 8.3 ABI与软件组织（composition）

# 8.4 例程的传参与返回值

# 8.5 值和参数引用

# 8.6 全局变量vs局部变量

# 8.7 寄存器的使用策略

# 8.8 栈帧（Stack Frames）和帧指针

# 8.9 实现兼容RISC-V ilp32指令集的例程

# 8.10 示例



