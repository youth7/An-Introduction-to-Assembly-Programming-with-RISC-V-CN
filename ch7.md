本章讨论如何用汇编语言实现高级语言中的条件、循环语句，例如C/C++中的`if-then`和`if-then-else`语句，以及`while`和`for`循环。本章也讨论了函数的调用和返回。

# 7.1 条件语句

## 7.1.1 `if-then`语句

下面的代码是一个用C语言编写的`if-then`语句。在这段代码中，如果`x`的值大于或等于10，就将`x`的值赋给变量`y`。`if-then`语句包含两个主要部分：

* **条件**（第1行）
* **then块**（第2~4行）

条件包含一个必须首先计算的布尔表达式，then块包含一组在布尔表达式为真时必须执行的语句

```c
if (x >= 10)
{
    y = x;
}
```

假设`x`是一个有符号整数（`int`），映射到寄存器`a3`， `y`映射到寄存器`a4`，下面的代码展示了如何用汇编语言实现前面的C代码。首先，代码将常量10加载到临时寄存器`t1`中（第1行）。然后，如果寄存器`a3`（变量`x`）的值小于10，则跳转到标签`skip`，否则，执行下一条指令（第3行），这条指令对应于*then块*。

```assembly
li t1, 10
blt a3, t1, skip # 如果x<10，跳转都skip标签
mv a4, a3 # 否则y = x
skip:
```

如果*then块*中有多个语句，它们可以放在`blt`指令（第2行）和`skip`标签（第4行）之间。

## 7.1.2 比较符号数 vs 比较无符号数

前面的代码使用`blt`指令来检查变量`x`的值是否小于10。如6.7.1节所述，这是正确的，因为变量`x`是一个有符号变量。如果变量`x`是一个无符号整数（C中的`unsigned`），程序员（或编译器）必须使用`bltu`指令来执行比较。

> 注意：重要的是要知道处理器不会自动推断寄存器（或内存）的内容是有符号值还是无符号值。程序员（或编译器）必须选定正确的指令让处理器进行比较。在前面的例子中，有符号变量比较用`blt`指令，无符号变量比较用`bltu`指令。

## 7.1.3 `if-then-else`语句

下面的代码是一个用C编写的`if-then-else`语句。在这段代码中，如果`x`的值大于或等于10，则变量`y`的值加1，否则将`x`的值赋值给变量`y`。`if-then-else`语句包含三个主要部分:

* *条件*（第1行）
* *then块*（第2~4行）
* *else块*（第6~8行）

*条件* 由布尔表达式组成，必须首先计算该表达式。*then块* 包含一组在布尔表达式求值为true时必须执行的语句，而 *else块* 包含一组在布尔表达式求值为false时必须执行的语句。

```C
if (x >= 10) {
    y = y + 1;
} else {
    y = x;
}
```

假设`x`是一个无符号整数（C中的`unsigned`），存到寄存器`a1`中， `y`存到寄存器`a2`中。下面的代码展示了如何用汇编语言实现前面的C代码。

1. 首先，代码将常量10加载到临时寄存器`t3`中（第1行）。
2. 然后，如果寄存器`a1`（变量`x`）的内容小于10，它就跳转到标签`else`来执行 *else块* 。
3. 否则，它执行下一条指令（第3行），这条指令对应于*then块* 的第一条指令。

```assembly
li t3, 10
bltu a1, t3, else # 如果x<10跳转到else标签
addi a2, a2, 1 # y = y + 1
j cont # 避开else标签
else:
    mv a2, a1 # y = x
cont:
```

如果*then块* 中有多条语句，它们可以放在指令`bltu`（第2行）和`j cont`指令（第4行）之间。如果 *else块* 中有多条语句，它们可以放在标签`else`（第5行）和标签`cont`（第7行）之间。

## 7.1.4 处理非平凡的布尔表达式

在某些情况下，条件语句中的布尔表达式可能包含多个操作。下面的代码展示了一个包含多个操作布尔表达式。在这种情况下，只有当变量`x`的内容大于或等于10且变量`y`的内容小于20时，才能执行 *then块*。

```c
if ((x>=10) && (y<20)){
    x = y
}
```

假设`x`和`y`是一个有符号整型变量（C中的`int`类型），分别映射到寄存器`a1`和`a2`，下面的代码展示了如何用汇编语言实现前面的C代码。

1. 首先，代码将常量10加载到临时寄存器`t1`中（第1行）。
2. 然后，如果寄存器`a1`（变量`x`）的内容小于10，则跳转到标签`skip`，即跳过*then块*的执行。注意，由于 *与*（and） 操作符（C中的`&&`操作符），如果布尔表达式的第一部分为false，那么整个表达式就为false，因此无需检查第二部分。如果布尔表达式的第一部分（第1行和第2行）被求值为true，那么代码必须检查第二部分，即执行第3和4行中的指令。在本例中，如果变量`y`的内容大于或等于20，则代码（第4行）跳过*then块*，跳转到`skip`标签。否则，它执行下一条指令（第5行），它对应于*then块*的第一条指令。

```assembly
li t1, 10
blt a1, t1, skip # 如果x>10调到skip标签  
li t1, 20
bge a2, t1, skip # 如果y<=20调到skip标签  
mv a1, a2 # x = y
skip:
```

下面的代码展示了一个包含 *或* (C中的`||`)操作符的布尔表达式的例子。

```c
if ((x>=10) || (y<20)){
    x = y
}
```

假设`x`和`y`是有符号整型变量（C中的`int`类型），分别存到寄存器`a1`和`a2`，则下面的代码展示了如何用汇编语言实现前面的C代码。

1. 首先，该代码将常量10加载到临时寄存器`t1`（第1行）。
2. 然后，如果寄存器`a1`（变量`x`）的内容大于或等于10，则跳转到标签`then`执行*then块*。注意，由于*或* 操作符（C中的`||`），如果布尔表达式的第一部分求值为true，那么整个表达式就为true，因此无需检查第二部分。如果布尔表达式的第一部分（第1行和第2行）计算结果为false，那么代码必须检查第二部分，即执行第3和4行中的指令。在这个例子中，如果变量`y`的内容大于或等于20，那么代码（第4行）将跳过*then块*，跳转到`skip`标签。否则执行下一个指令（第5行），该指令对应于C代码中的*then块*

```assembly
li t1, 10
bge a1, t1, then # jumps to then if x >= 10
li t1, 20
bge a2, t1, skip # jumps to skip if y >= 20
then:
    mv a1, a2 # x = y
skip:
```

## 7.1.5 嵌套的if语句

嵌套的`if-then`和`if-then-else`是这样一种if语句：其中的 *then块* 或*else块* 包含其他if语句。下面的代码展示了一个嵌套`if-then`语句的示例。注意，这里有两个`if-then语句`：一个外部的（第1~8行)和一个内部的（第4~7行）。外部`if-then`语句的 *then块* 包含两个语句：一个变量赋值语句（第3行）和内部的`if-then`语句（第4~7行）。
```C
if (x == 10)
{
    x = 5;
    if (y == 20)
    {
        x = 0;
    }
}
```

从外部的`if-then`语句开始，可以很容易地将前面的代码转换为汇编代码。假设`x`和`y`分别是映射到寄存器`a1`和`a2`的变量，下面的代码给出了外部`if-then`语句的框架。
```assembly
li t1, 10
bne a1, t1, skip # 如果x != 10，则跳转到skip标签
# <= 在这里插入then块的代码
skip:
```

当代码的框架生成后，下一步就是生成 *then块* 的代码，下面最终的代码：

```assembly
li t1, 10
bne a1, t1, skip # 如果x != 10，则跳转到skip标签
li a1, 5 # x = 5
li t1, 20
bne a2, 20, skip_inner # 如果y != 20，则跳转到skip_inner
li a1, 0 # x = 0
skip_inner:
skip:
```

在前面的例子中，我们使用了两个不同的标签，一个跳过外部if语句的 *then块* 的执行（`skip`标签），另一个跳过内部if语句的 *then块* 的执行（`skip_inner`标签）。在这种情况下，由于两个标签表示相同的地址（注意，两个标签之间没有任何指令或数据），我们可以使用单个跳过标签来简化代码。但这种简化并不影响汇编程序生成的代码，因为标签仅仅是地址的标记。



# 7.2 循环语句

循环语句用于重复一组语句。在本节中我们将讨论如何实现汇编中最常见的循环语句。

# 7.3 调用例程以及从例程中返回

# 7.4 示例
