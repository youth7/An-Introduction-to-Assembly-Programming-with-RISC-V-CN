本章讨论如何用汇编语言实现高级语言中的条件、循环语句，例如C/C++中的`if-then`和`if-then-else`语句，以及`while`和`for`循环。本章也讨论了函数的调用和返回。

# 7.1 条件语句

## 7.1.1 `if-then`语句

下面的代码是一个用C语言编写的`if-then`语句。在这段代码中，如果`x`的值大于或等于10，就将`x`的值赋给变量`y`。`if-then`语句包含两个主要部分：

* **条件**（第1行）
* **then块**（第2~4行）

条件包含一个必须首先计算的布尔表达式，then块包含一组在布尔表达式为真时必须执行的语句

```c
if (x >= 10)
{
    y = x;
}
```

假设`x`是一个有符号整数（`int`），映射到寄存器`a3`， `y`映射到寄存器`a4`，下面的代码展示了如何用汇编语言实现前面的C代码。首先，代码将常量10加载到临时寄存器`t1`中（第1行）。然后，如果寄存器`a3`（变量`x`）的值小于10，则跳转到标签`skip`，否则，执行下一条指令（第3行），这条指令对应于*then块*。

```assembly
li t1, 10
blt a3, t1, skip # 如果x<10，跳转都skip标签
mv a4, a3 # 否则y = x
skip:
```

如果*then块*中有多个语句，它们可以放在`blt`指令（第2行）和`skip`标签（第4行）之间。

## 7.1.2 比较符号数 vs 比较无符号数

前面的代码使用`blt`指令来检查变量`x`的值是否小于10。如6.7.1节所述，这是正确的，因为变量`x`是一个有符号变量。如果变量`x`是一个无符号整数（C中的`unsigned`），程序员（或编译器）必须使用`bltu`指令来执行比较。

> 注意：重要的是要知道处理器不会自动推断寄存器（或内存）的内容是有符号值还是无符号值。程序员（或编译器）必须选定正确的指令让处理器进行比较。在前面的例子中，有符号变量比较用`blt`指令，无符号变量比较用`bltu`指令。

## 7.1.3 `if-then-else`语句

下面的代码是一个用C编写的`if-then-else`语句。在这段代码中，如果`x`的值大于或等于10，则变量`y`的值加1，否则将`x`的值赋值给变量`y`。`if-then-else`语句包含三个主要部分:

* *条件*（第1行）
* *then块*（第2~4行）
* *else块*（第6~8行）

*条件* 由布尔表达式组成，必须首先计算该表达式。*then块* 包含一组在布尔表达式求值为true时必须执行的语句，而 *else块* 包含一组在布尔表达式求值为false时必须执行的语句。

```C
if (x >= 10) {
    y = y + 1;
} else {
    y = x;
}
```

假设`x`是一个无符号整数（C中的`unsigned`），存到寄存器`a1`中， `y`存到寄存器`a2`中。下面的代码展示了如何用汇编语言实现前面的C代码。

1. 首先，代码将常量10加载到临时寄存器`t3`中（第1行）。
2. 然后，如果寄存器`a1`（变量`x`）的内容小于10，它就跳转到标签`else`来执行 *else块* 。
3. 否则，它执行下一条指令（第3行），这条指令对应于*then块* 的第一条指令。

```assembly
li t3, 10
bltu a1, t3, else # 如果x<10跳转到else标签
addi a2, a2, 1 # y = y + 1
j cont # 避开else标签
else:
    mv a2, a1 # y = x
cont:
```

如果*then块* 中有多条语句，它们可以放在指令`bltu`（第2行）和`j cont`指令（第4行）之间。如果 *else块* 中有多条语句，它们可以放在标签`else`（第5行）和标签`cont`（第7行）之间。

## 7.1.4 处理非平凡的布尔表达式

在某些情况下，条件语句中的布尔表达式可能包含多个操作。下面的代码展示了一个包含多个操作布尔表达式。在这种情况下，只有当变量`x`的内容大于或等于10且变量`y`的内容小于20时，才能执行 *then块*。

```c
if ((x>=10) && (y<20)){
    x = y
}
```

假设`x`和`y`是一个有符号整型变量（C中的`int`类型），分别映射到寄存器`a1`和`a2`，下面的代码展示了如何用汇编语言实现前面的C代码。

1. 首先，代码将常量10加载到临时寄存器`t1`中（第1行）。
2. 然后，如果寄存器`a1`（变量`x`）的内容小于10，则跳转到标签`skip`，即跳过*then块*的执行。注意，由于 *与*（and） 操作符（C中的`&&`操作符），如果布尔表达式的第一部分为false，那么整个表达式就为false，因此无需检查第二部分。如果布尔表达式的第一部分（第1行和第2行）被求值为true，那么代码必须检查第二部分，即执行第3和4行中的指令。在本例中，如果变量`y`的内容大于或等于20，则代码（第4行）跳过*then块*，跳转到`skip`标签。否则，它执行下一条指令（第5行)，它对应于*then块*的第一条指令。

```assembly
li t1, 10
blt a1, t1, skip # 如果x>10调到skip标签  
li t1, 20
bge a2, t1, skip # 如果y<=20调到skip标签  
mv a1, a2 # x = y
skip:
```

下面的代码展示了一个包含 *或* (C中的`||`)操作符的布尔表达式的例子。

```c
if ((x>=10) || (y<20)){
    x = y
}
```

假设`x`和`y`是有符号整型变量（C中的`int`类型），分别存到寄存器`a1`和`a2`，则下面的代码展示了如何用汇编语言实现前面的C代码。

1. 首先，该代码将常量10加载到临时寄存器`t1`（第1行）。
2. 然后，如果寄存器`a1`（变量`x`）的内容大于或等于10，则跳转到标签`then`执行*then块*。注意，由于*或* 操作符（C中的`||`），如果布尔表达式的第一部分求值为true，那么整个表达式就为true，因此无需检查第二部分。如果布尔表达式的第一部分（第1行和第2行）计算结果为false，那么代码必须检查第二部分，即执行第3和4行中的指令。在这个例子中，如果变量`y`的内容大于或等于20，那么代码（第4行）将跳过*then块*，跳转到`skip`标签。否则执行下一个指令（第5行），该指令对应于C代码中的*then块*

```assembly
li t1, 10
bge a1, t1, then # jumps to then if x >= 10
li t1, 20
bge a2, t1, skip # jumps to skip if y >= 20
then:
    mv a1, a2 # x = y
skip:
```

## 7.1.5 嵌套的if语句

# 7.2 循环语句

# 7.3 调用例程以及从例程中返回

# 7.4 示例
