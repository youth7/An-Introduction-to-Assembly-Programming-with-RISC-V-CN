RISC-V是一种模块化的指令集体系结构，允许设计各种微处理器。这种灵活性允许行业参与者为具有不同需求的应用程序设计微处理器，包括用于嵌入式设备的超低功耗和紧凑的微处理器，以及用于运行在数据中心上的强大服务器的高性能微处理器。

为了实现这种灵活性，RISC-V的ISA依赖于4种基本ISA和几种扩展，以实现ISA的专用版本。表6.1给出了基本的ISA及其一些扩展。

**基本指令集**

| 名称   | 描述                             |
| ------ | -------------------------------- |
| RV32I  | 32位整数指令集                   |
| RV32E  | 32位整数指令集（嵌入式微处理器） |
| RV64I  | 64位整数指令集                   |
| RV128I | 128位整数指令集                  |



**扩展指令集**

| 名称 | 描述                                                     |
| ---- | -------------------------------------------------------- |
| M    | 乘法标准扩展                                             |
| A    | 原子指令标准扩展                                         |
| F    | 单精度浮点数标准扩展                                     |
| D    | 双精度浮点数标准扩展                                     |
| G    | 基本指令集 + 以上扩展，即基本指令集 + MAFD               |
| Q    | 四精度（quad-precision）浮点数标准扩展                   |
| L    | 十进制浮点数标准扩展                                     |
| C    | 压缩的指令（compressed instructions）标准扩展            |
| B    | 位操作标准扩展                                           |
| J    | 动态转换语言（dynamically translated languages）标准扩展 |
| T    | 事务性内存标准扩展                                       |
| P    | 单指令多数据流标准扩展                                   |
| V    | 向量操作标准扩展                                         |
| N    | 用户级中断标准扩展                                       |
| H    | hypervisor标准扩展                                       |

> 表6.1

在本书中，我们将专注于RV32IM，它包括RV32I基本指令以及支持乘除法的M扩展指令。RV32IM具有以下属性:

* 支持32位地址空间
* 包含33个32位寄存器
* 使用二进制补码表示有符号整数
* 含有基本指令，包括整数计算指令，整数加载/存储指令，流程控制指令
* 包含对寄存器中的值进行乘法、除法指令



# 6.1 数据类型和内存组织

ISA原生数据类型是ISA可以天生就能自然处理的数据类型，表6.2展示了RV32I原生数据类型的大小

| RV32I原生数据类型名称 | 大小（字节） |
| --------------------- | ------------ |
| `byte`                | 1            |
| `unsigned   byte`     | 1            |
| `halfword`            | 2            |
| `unsigned   halfword` | 2            |
| `word`                | 4            |
| `unsigned   word`     | 4            |

与其他现代其它的ISA类似，RISC-V是字节可寻址存的，即每个内存位置存储一个字节并有一个唯一的地址，如图6.1所示

![](./imgs/ch6/6.1.png)

> 图6.1

大于1字节的数据会存储在多个内存位置上。因此，在内存中存`halfword`类型的数据时，会将2个字节存储在2个连续的内存位置上。存`word`类型的数据时，会将4个字节存储在4个连续的内存位置上。

在将C语言的代码转换为RV32I汇编代码时，必须将C中的数据类型转换为RISC-V原生数据类型。表6.3给出了C原生数据类型到RV32I原生数据类型的映射。C语言中的所有指针（例如`int*`、`char*`和`void*`）都表示内存地址，并映射到`unsigned word`数据类型。

| C语言数据类型     | RV32I原生数据类型   | 大小 |
| ----------------- | ------------------- | ---- |
| `bool`            | `byte`              | 1    |
| `char`            | `byte`              | 1    |
| `unsigned char`   | `unsigned byte`     | 1    |
| `short`           | `halfword`          | 2    |
| `unsigned  short` | `unsigned halfword` | 2    |
| `int`             | `word`              | 4    |
| `unsigned int`    | `unsigned word`     | 4    |
| `long`            | `word`              | 4    |
| `unsigned long`   | `unsigned word`     | 4    |
| `void*`           | `unsigned word`     | 4    |

> 表6.3

# 6.2 RV32I 寄存器

RV32I的非特权ISA包含33个32位寄存器，也称为非特权寄存器。

寄存器`x0`是一个硬连线到0（hard-wired to zero）的特殊寄存器，也就是说，读取它的值时总是返回值0。寄存器`pc`保存程序计数器，即下一条要执行的指令的地址。每次执行一条指令时，它的内容都会自动更新，而且可能会被称为 *流程控制（control-flow）* 的特殊指令更新。

其余的寄存器（`x1`~`x31`）是通用寄存器，可以互换使用。尽管如此，遵循寄存器使用标准通常是很重要的，这将在后面讨论。例如在调用函数时，总是使用同一组寄存器来传递参数。为便于编程，这些寄存器被赋予了别名，可以在编写汇编代码时使用。这样做的目的是让程序员在编程时使用更有意义的寄存器名。例如，写`a0`而不是`x10`来引用保存函数第一个参数的寄存器。表6.4给出了非特权寄存器的列表、别名及其描述。

> 译注：hard-wired这个单词的解释如下：
>
> *make (a function) a permanent feature in a  computer by means of permanently connected circuits, so that it cannot  be altered by software*

| 寄存器  | 别名                                                  | 描述                | 调用者保存 | 被调用者保存 |
| ------- | ----------------------------------------------------- | ------------------- | ---------- | ------------ |
| x0      | zero                                                  | 硬连线到0           |            |              |
| x1      | ra（**r**eturn **a**ddress）                          | 保存返回地址        | ✔️          |              |
| x2      | sp（**s**tack **p**ointer）                           | 栈指针              |            | ✔️            |
| x3      | gp（**g**lobal **p**ointer）                          | 全局指针            |            |              |
| x4      | tp（**t**hread **p**ointer）                          | 线程指针            |            |              |
| x5-x7   | t0-t2（**t**emporary register **0-2**）               | 临时寄存器0-2       | ✔️          |              |
| x8      | s0/fp（**s**aved register 0 / **f**rame **p**ointer） | 保存寄存器0或帧指针 |            | ✔️            |
| x9      | s1（**s**aved register 1 ）                           | 保存寄存器1         |            | ✔️            |
| x10-x17 | a0-a7（**f**unction arguments 0 to 7）                | 函数参数0-7         | ✔️          |              |
| x18-x27 | s2-s11（**s**aved register **2-11** ）                | 保存寄存器2-11      |            | ✔️            |
| x28-x31 | t3-t7（**t**emporary register **3-7**）               | 临时寄存器3-7       | ✔️          |              |
| pc      | pc（**p**rogram **c**ounter）                         | 程序计数器          |            |              |

> 表6.4 RV32I非特权寄存器

# 6.3 Load/Store 架构

**load/store体系结构**是一种指令集体系结构，它要求在操作值之前，必须显式地从内存中读取值，或将值写入内存。换句话说，要从内存中读/写一个值，软件必须执行一个load/store指令。

> 译注：根据《计算机体系结构》，指令系统可以分为：
>
> * 堆栈型
>
> * 累加型
>
> * register型
>
>   * register-register型（即load/store）
>   * register-memory型
>
>   

RISC-V是一种load/store体系结构，因此，为了对存储在内存中的数据执行操作（例如算术操作），它要求先执行load指令，将数据从内存加载到寄存器。让我们考虑以下汇编代码，它从内存中加载一个值，将其乘以2，并将结果回存到内存中

```assembly
lw a5, 0(a0)
add a6, a5, a5
sw a6, 0(a0)
```

第一个指令叫load word，用助记符`lw`表示，是一个加载指令。它从内存中检索一个`word`的值，并将其存储在寄存器`a5`中。表达式`0(a0)`表示被加载的值的内存地址。在本例中，地址的值是寄存器`a0`的值和常数0的和。换句话说，在执行该加载指令时，如果寄存器`a0`包含值8000，硬件将从地址8000加载数据。

第二个指令由助记符`add`表示，它将两个值相加并将结果存在寄存器中。在本例中，它将来自寄存器`a5`的值相加，并将结果存储在寄存器`a6`上。注意，由于两个源操作数相同，即`a5`，结果相当于将`a5`的值乘以2。

最后，第三条指令称为store word，由助记符`sw`表示，将寄存器`a6`中的值回存到内存中。同样，表达式`0(a0)`表示需要写入数据的内存地址。

# 6.4 伪指令

# 6.5 逻辑、位移和算术指令

# 6.6 数据移动指令

# 6.7 流程控制指令

# 6.8 条件设置（Conditional set）指令

# 6.9 溢出检测

# 6.10 多字节变量的算术运算

