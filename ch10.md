# 10.1 简介
如前几章所述，CPU从主存中获取指令并执行。在这种情况下，系统（注意，这里强调的是系统，不是CPU）中发生的大多数操作都是由CPU发起的，这些操作都是CPU指令执行的结果。例如，在主存和外设之间读写数据是由CPU在执行指令时触发的事件。但有些事件是由其他硬件（如外设）发起的。例如在9.4节讨论的系统中，当按下一个小键盘的键时，小键盘控制器将该信息记录到小键盘控制器寄存器上。即使事件不是由CPU发起的，它也可能需要CPU的关注，例如它可能需要CPU执行一些操作。因此，必须有一种方法来通知CPU有一些外设需要它的关注。  
为了说明这个概念，让我们考虑图10.1所示的计算系统，它包含一个RV32I CPU、主存和一个小键盘。  

![](./imgs/ch10/10.1.png)  
> 图10.1

小键盘连接到小键盘控制器，该控制器包含两个8位寄存器：Data寄存器和Status寄存器。映射到地址0x00000050的Data寄存器存储了一个值，表示键盘上按下的最后一个键。映射到地址0x00000054的Status寄存器包含一个值，表示键盘的当前状态。状态寄存器的最低有效位（第0位那个bit），称为就绪位（READY bit），表示CPU上次从Data寄存器读取值后是否按下了键盘。如果它的值是0，意味着自上次CPU从Data寄存器读取值以来，没有按下任何键，否则，它的值是1。状态寄存器的第二个最低有效位（第1位那个bit），称为OVRN位，表示自从CPU上一次从Data寄存器读取值以来，键盘是否被多次按下。如果它的值是1，则意味着自上次CPU从Data寄存器读取值以来，键盘被按了不止一次。由于小键盘控制器只包含一个Data寄存器，如果在CPU获得读取Data寄存器的机会之前多次按下小键盘，一个或多个的按键值会丢失。这种情况称为OVRN (overrun，数据溢出)，可以通过检查Status寄存器的OVRN位来检测。  

程序读取Data寄存器内容的时间越长，数据溢出的可能性就越高。为防止数据溢出，按下键盘后，通常将Data寄存器的值复制到位于主存中的先进先出（FIFO）队列。这种方法如图10.2所示，它使用一个长度为8的循环缓冲区和两个指针实现了FIFO队列，一个指向队列头（插入的最老元素），另一个指向队列尾（插入的最后一个元素）。在这个例子中，按键1、9和6被按下并存储在队列中。

![](./imgs/ch10/10.2.png)  
> 图10.2

在这种方法中，每当按下一个键时，它的值就会被推送到队列的尾部，而每当用户程序需要读取一个键值时，它就会从队列的头部弹出该键，而不是从键盘Data寄存器读取。注意，队列作为缓冲区能够存储多个键值，允许程序在读取每个键值之前执行较长的计算。图10.3说明了按下键盘键9时会发生什么。
* 首先，按下了键9。①
* 然后，键盘控制器在Data和Status寄存器上记录该信息。②
* 最后，CPU执行一个例程，将Data寄存器的值推送到队列尾部。③

![](./imgs/ch10/10.3.png)  
> 图10.3

将值从键盘的Data寄存器复制到位于主存的队列通常是由CPU通过执行例程来实现的。在这种情况下，每当键被按下时，CPU必须尽快执行该例程，以防止数据溢出。有两种主要方法可以通知CPU去处理由外部硬件引起的事件：轮询和硬件中断。

## 10.1.1 轮询

# 10.2 外部中断

## 10.2.1  检测外部中断

## 10.2.2  调用适当的中断服务例程

# 10.3 RV32I上的中断

## 10.3.1 控制与状态寄存器

## 10.3.2 中断相关的控制与状态寄存器

## 10.3.3 中断处理流程

## 10.3.4 实现一个中断服务例程

## 10.3.5 初始化中断处理机制

