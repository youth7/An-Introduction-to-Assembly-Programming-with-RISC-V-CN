前几章讨论过，CPU执行存储在主存中的程序。在这个过程中，CPU从主存中获取程序指令并执行，这可能使得CPU在主存中加载或存储数据。前面的章节还解释了用户级程序通过调用操作系统（的接口）来执行输入和输出操作。

本章讨论程序如何直接与IO硬件设备交互来执行IO操作。在为不包含OS的系统开发软件，或实现OS组件（如设备驱动程序）时，这很有用。

本章剩下部分组织如下：
* 9.1节介绍了外设的概念，并讨论了外设与CPU的连接方式。
* 9.2节介绍了程序与外设交互的两种主要方法：端口映射I/O和内存映射I/O。
* 9.3节讨论了在基于RISCV的计算系统上如何执行I/O操作。
* 最后，9.3节讨论了忙等（Busy waiting）的概念。
  
# 9.1 外设

外设是连接到计算机的I/O设备。有若干种不同类型的外设。鼠标、键盘、图像扫描仪、条形码阅读器、游戏控制器、麦克风、网络摄像头和只读内存都是输入设备的例子。显示器、投影仪、打印机、耳机和计算机扬声器都是输出设备的例子。还有一些设备可以同时执行输入和输出操作，例如数据存储设备（包括磁盘驱动器、USB闪存驱动器、记忆卡和磁带驱动器）、网卡等。

IO设备通过总线与CPU通讯，总线是在计算机组件之间传输信息的通信系统。这种系统通常由负责传输信息的线路和协调通信的相关电路组成。图9.1展示了一个计算机系统，其中系统总线连接了CPU、主内存、持久话存储设备（HDD）、输入设备和输出设备。


![](./imgs/ch9/9.1.png)
> 图9.1

外设通常包含寄存器或内部存储，CPU通过访问这些寄存器或存储器来执行输入和输出操作。为讨论这个概念，让我们考虑一个假想的计算系统，它有一个七段数码管（一个输出外设）连接到显示控制器，显示控制器又通过总线连接到CPU，如图9.2所示。

![](./imgs/ch9/9.2.png)
> 图9.2

七段数码管是包含七个段（segment）和一个可以单独发光的点的设备。现代的七段数码管由七个LED（每个segment一个）和光点组成。segment和点被放置在显示器上，因此可以通过点亮一些segment来显示类似于十进制数字的图案。例如，我们可以打开a、f、g、c和d段，以显示类似于十进制数字5的图案，如图9.2所示。

显示控制器是负责控制七段数码管的装置。它使用电线连接到7个segment，并根据8位的控制寄存器的值打开或关闭每个segment和光点。控制寄存器的每个位控制每个segment或光点的打开和关闭。在本例中，第7、6、5、4、3、2、1和0位（最右边的位）分别控制光点和a、b、c、d、e、f、g这几个segment。图9.3展示了必须往控制寄存器写入0x5b这个值，才能显示类似于十进制数字5。

![](./imgs/ch9/9.3.png)
> 图9.3

在前面的例子中，七段数码管由显示控制器控制，该控制器根据控制寄存器的值，打开和关闭对应的segment和光点。在这种情况下，为了使用显示控制器执行输出操作，CPU必须将一个值写入显示控制器控制寄存器。一般来说，要使用I/O设备执行输出或输入操作，**CPU对设备的控制器中的寄存器或内部内存进行读写**。

下一节将讨论CPU如何读写外设的寄存器及其内部内存。

# 9.2 与外设交互

CPU通过在总线上发送地址、数据和命令与主存进行交互。例如，要将8位的值0x55写入地址为0x8000的内存中，CPU可以通过总线将写操作命令、地址和值发送到主内存。而从内存中读数据，CPU可以发送读操作命令和内存地址，并且等待主存把数据放在总线上，然后它把数据复制到它的内部寄存器中。CPU使用相同的方法与外设的控制器交互，即CPU通过总线，向控制器发送/接收信息、命令、地址和数据。

CPU通常通过一个或多个总线物理地连接到主内存和外设控制器。总线有很多种，它们的组织和实现可能差别很大。例如，一些总线可能使用同一组线路来传输地址、数据和命令，而另一些总线可能使用专用线路来完成这些操作。此外，总线的数量及其在系统上的配置可能会因计算系统而有很大差异。

尽管总线的实现和组织可能差异很大，但它们的特性通常对程序员是透明的，即它们不会影响程序员如何生成与外设控制器或主内存交互的代码。CPU ISA通常给程序员提供一些指令，隐藏了CPU、外设、总线之间如何交互的细节（例如，它们的协议和内部工作原理）。这些指令允许程序员让CPU以一种简单的方式对外设的寄存器及其内部存储进行IO。例如，RV32I ISA包含加载和存储指令（例如，`lw`和`sw1`），允许程序员指示CPU对主存进行IO，而无需考虑连接CPU和主存的总线是如何工作的。

系统上可能有几个外设，每个外设可能有多个寄存器或内部存储。因此，程序员必须有一种方法来指定汇编指令要访问的（外设的）寄存器或内存。这通常是通过将每个外设寄存器和内存**关联到不同的标识符**（通常是一个整数）来完成的，**这个标识符就是地址或I/O端口**。在这种情况下，用于与外设交互的指令，通常通过**自身的地址或I/O端口**，来标识外设的寄存器或内存地址。

9.2.1节和9.2.2节会讨论通过执行CPU指令来访问外设寄存器及其内部内存的两种主要方法。


## 9.2.1 端口映射I/O（Port-mapped I/O）
端口映射I/O，也称为隔离I/O，是一种访问外设寄存器及其内部存储的方法（这些寄存器和内部存储需要用特殊的ISA指令进行I/O操作）。这种方法有两个核心概念：I/O端口和I/O指令。
* I/O指令是一种专用于访问外设的特殊指令。
* I/O端口是一个无符号整数，用于标识外设的寄存器和内部存储的地址。

程序员使用这个标识符来指定，在用I/O指令执行I/O操作时，必须访问哪些外设寄存器或内部存储。

为说明这个概念，我们考虑Intel的IA-32指令集。它包含两个I/O指令，用于在CPU寄存器和外设寄存器或内部存储之间复制数据，分别是从"从端口输入"（`in`指令）和"输出到端口"（`out`指令）。

`in`指令需要两个参数：I/O端口和目标寄存器（即`al`/`ax`/`eax`寄存器）。该指令从外设的寄存器、或被I/O端口指定的内部存储中，复制一个值到CPU的目标寄存器中。下面的代码展示了使用`in`指令从外设的I/O端口0x71中读取一个8位的值，然后复制到CPU的`al`寄存器中。

```assembly
in 0x71, %al
```

`out`指令也需要两个操作数。第一个指定了目标I/O端口，第二个指定了源CPU寄存器。`out`指令将源CPU寄存器中的值，复制到外设寄存器或内部存储（由I/O端口操作数标识）中。下面的代码展示了使用`out`指令将存储在CPU `al`寄存器中的8位值，写入由I/O端口0x70标识的外部寄存器（或内部存储）中。

```assembly
out %al, 0x70
```

## 9.2.2 内存映射I/O（Memory-mapped I/O）

I/O地址空间定义了有效的I/O端口的集合。例如在IA-32中，I/O地址空间由$2^{16}$（即64KB）个16位的、可独立寻址的端口组成，端口号从0到0xFFFF。端口映射的I/O地址空间与主存地址空间是不同的。即主存的一个内存地址（例如0x70），可以与映射到外设寄存器的I/O端口（例如0x70），具有相同的值。

**内存映射I/O，是一种使用常规内存访问指令访问外设寄存器及其内部存储的方法**。在内存映射I/O中，只有一个地址空间，这个空间的一部分映射到主存，另一部分映射到外设寄存器和内部存储。在这种情况下，从主存读取/写入数据的指令（例如，load和store指令），同样适用于从外设寄存器及其内部存储中读取/写入数据。地址定义了是访问主存，还是访问外设的寄存器和内部内存。图9.4展示了真实的计算系统上映射到主存和多个外设的地址空间。地址0x70000000到0x80000000映射到主存；因此，对这些地址进行load/store操作，会使得CPU在主存中读写数据。而对地址0x53F84000执行load/store操作，会使得CPU对GPIO外设上的寄存器读写数据。

![](./imgs//ch9/9.4.png)
> 图9.4



# 9.3 RISC-V上的IO操作

RISC-V ISA（包括RV32I ISA）的输入输出操作采用了内存映射I/O这种方式。因此，输入操作是通过执行load系指令（例如，`lw`）来执行的，而输出操作是通过store系指令（例如`sw`）来执行的。这些指令所执行的地址，都被映射到外设的寄存器或者内部存储中。  

为了说明RISC-V上的I/O操作，让我们考虑一个电梯计算系统，它包含一个RV32I CPU、主存、一个七段数码管和一个楼层传感器，如图9.5所示。

![](./imgs//ch9/9.5.png)
> 图9.5

如前几节所述，七段数码管由显示控制器控制。但在本例中，显示控制器的`Control Reg`被映射到地址0x00000040。楼层传感器检测电梯所在楼层，而楼层传感控制器将该信息记录在`Data Reg`上，这是位于楼层传感控制器中的一个8位寄存器，它被映射到地址0x00000080。如果电梯位于第四层，楼层传感控制器将值4（0b00000100）存储在`Data Reg`中。

下面的代码显示了一个例程，它从楼层传感控制器读取电梯的楼层的值（第6~7行），然后转换为configuration byte（第8~10行），并将configuration byte写入显示控制器的`Control Reg`中以设置7段数码管的显示（第11~12行）

```assembly
.section .text
.set DISPLAY_CONTROL_REG_PORT, 0x00000040
.set FLOOR_DATA_REG_PORT, 0x00000080
 
update_display:
    li  a0, FLOOR_DATA_REG_PORT    # 读取的FLOOR_DATA_REG_PORT
    lb  a1, (a0)                   # 将FLOOR_DATA_REG_PORT所指向的地址中的值加载到a1中，此时等于读取了楼层的值
    la  a0, floor_to_pattern_table # 将floor_to_pattern_table所代表的地址加载到a0，floor_to_pattern_table指向的是一个表
    add t0, a0, a1                 # a1 + a0 ，即根据楼层的偏移量，在floor_to_pattern_table中找出所需的configuration byte的地址
    lb  a1, (t0)                   # 加载configuration byte
    li  a0, DISPLAY_CONTROL_REG_PORT 
    sb  a1, (a0)                   # 将configuration byte的值写入DISPLAY_CONTROL_REG_PORT的地址中，设置七段数码管显示
    ret # Returns

.section .rodata
floor_to_pattern_table:
    .byte 0x7e,0x30,0x6d,0x79,0x33,0x5b,0x5f,0x70,0x7f,0x7b
```

在9.1节讨论过，configuration byte的每个bit控制（七段数码管中）每个segment（或光点）的打开或关闭。因此代码必须将楼层号转换为一个configuration byte，该configuration byte打开某些segment，使显示的图案与楼层号一致。例如，如果电梯位于四层（楼层号为4），代码必须写入0x33 （0b00110011）来打开b、c、f和g段，如图9.5所示。请注意，该代码使用了一个表（`floor_to_pattern_table`），可以通过楼层号索引该表，以获取正确的configuration byte。

# 9.4 忙等（Busy waiting）
**忙等（Busy waiting）是一种技术，它通过在循环中反复检查某个条件以等待该条件为真。一旦条件为真，代码就会离开循环，继续执行剩下的代码**。

在许多情况下，当与外设交互时，程序可能需要等待某些条件为真，然后才能执行IO操作。在这种情况下，程序员可能会采用忙等来控制执行流程。为了说明这个概念，我们考虑一个计算系统，该系统包含一个RV32I CPU、主存和一个小键盘，如图9.6所示。

![](./imgs/ch9/9.6.png)

> 图9.6

小键盘连接到小键盘控制器，小键盘控制器又通过总线连接到CPU。小键盘控制器包含两个8位寄存器：Data存器和Status寄存器。映射到地址0x00000050的Data存器存储了一个值，表示小键盘上按下的最后一个键。例如，如果按键"8"被按下，那么，Data存器设置为数字8。

映射到地址0x00000054的Status寄存器包含一个值，表示小键盘的当前状态。Status寄存器的最低有效位（第0位那个bit），称为就绪位（READY bit），表示CPU上次从Data存器读取值后是否按下了小键盘。如果它的值是0，则意味着自上次CPU从Data存器读取值以来，没有按下任何键。如果它的值是1，则自上次CPU从Data存器读取值以来，至少按下了一个键。

Status寄存器的第二个最低有效位（第1位那个bit），称为OVRN bit，表示自从CPU上一次从Data存器读取值以来，小键盘是否被多次按下。如果它的值是1，则意味着自上次CPU从Data存器读取值以来，小键盘被按了不止一次。请注意，由于小键盘控制器只包含一个Data存器，并且它存储了最后按下的键的值，如果在CPU获得读取Data存器的机会之前多次按下小键盘，一个或多个的按键值会丢失。这种情况称为OVRN (overrun，数据溢出)，可以通过检查Status寄存器的OVRN位来检测。

现在，假设程序员需要实现一个名为`read_keypad`的例程，它会一直等待，直到小键盘被按下，然后返回按下的最后一个键的值。如果某次从Data寄存器读取值后（并且在下一次读取前）按下小键盘多次，这个例程需要返回值-1

下面的代码展示了`read_keypad`的实现，该例程采用忙等技术，待小键盘被按下后才去读取小键盘控制器的Data寄存器。
* 首先，它将小键盘Status寄存器的内容读取到寄存器`a0`中（第8~9行）
* 然后，它使用掩码`READY_MASK`对就绪位执行按位与操作（第10行），以检查就绪位是否被设置，并在结果为0时跳回到例程的起始处（第11行）。
* 接着，使用掩码`OVRN_MASK`对就OVRN bit执行按位与操作（第12行），以检查键盘是否被多次按下，如果结果不是0，则跳转到`ovrn_occured`标签（第13行）
* 最后，它从键盘控制器的Data寄存器读取键值（第14行和第15行）并返回。

```assembly
.text
.set DATA_REG_PORT, 0x00000050
.set STAT_REG_PORT, 0x00000054
.set READY_MASK, 0b00000001
.set OVRN_MASK, 0b00000010
  
read_keypad:
    li a0, STAT_REG_PORT    # 将status寄存器地址的值加载到a0
    lb a0, 0(a0)            # 将status寄存器的值加载到a0
    andi t0, a0, READY_MASK # 获取就绪位的值
    beqz t0, read_keypad    # 如果就绪位为0，则返回程序开头，否则往下走
    andi t0, a0, OVRN_MASK  # 获取OVRN bit的值
    bnez t0, ovrn_occured   # 如果不等于0，则跳转到ovrn_occured，否则往下走
    la a0, DATA_REG_PORT    # 加载Data寄存器的地址
    lb a0, 0(a0)            # 加载Data寄存器的值
    ret                     # 返回
ovrn_occured:
    li a0, -1               # 设置返回值-1
    ret                     # 返回
```

忙等是一种简单的技术，但它可能非常低效，因为它会让CPU一直处于繁忙状态直到条件为真（例如，按下了一个键）。下一章将讨论一些技术（轮询和中断），用于在等待条件为真时释放CPU，以便执行其它有用的工作。